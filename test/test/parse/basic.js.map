{
  "version": 3,
  "sources": ["../../src/parse/basic.ts"],
  "sourcesContent": ["import assert from \"node:assert\";\n\nimport {Iter} from \"@j-cake/jcake-utils/iter\";\nimport {createParser, Lex} from \"@j-cake/jcake-utils/parse\";\n\nconst nums = Iter(Lex.createLexer({\n    num: tok => tok.match(/^\\d+/)?.[0],\n    op: tok => ['+', '-', '*', '/'].find(i => tok.startsWith(i)),\n    bracket: tok => ['(', '[', '{', '}', ']', ')'].find(i => tok.startsWith(i)),\n    ws: tok => tok.match(/^\\s+/)?.[0],\n})([``]))\n    .filter(i => i.type !== 'ws');\n\ntype T = typeof nums extends AsyncIterable<Lex.Token<infer M>> ? M : never;\ntype K = string;\n\nconst numList = await createParser<T, K>('nums', num => num)\n    .repeat(createParser<T, K>('num', (num: Lex.Token<T>) => num.src)\n        .oneOf({type: 'num'}, {type: 'hex'}))\n    .exec(nums[Symbol.asyncIterator]());\n\nconsole.log(numList);\nassert(numList !== null);\n"],
  "mappings": ";AAAA,OAAO,YAAY;AAEnB,SAAQ,YAAW;AACnB,SAAQ,cAAc,WAAU;AAEhC,IAAM,OAAO,KAAK,IAAI,YAAY;AAAA,EAC9B,KAAK,SAAO,IAAI,MAAM,MAAM,IAAI;AAAA,EAChC,IAAI,SAAO,CAAC,KAAK,KAAK,KAAK,GAAG,EAAE,KAAK,OAAK,IAAI,WAAW,CAAC,CAAC;AAAA,EAC3D,SAAS,SAAO,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,EAAE,KAAK,OAAK,IAAI,WAAW,CAAC,CAAC;AAAA,EAC1E,IAAI,SAAO,IAAI,MAAM,MAAM,IAAI;AACnC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EACH,OAAO,OAAK,EAAE,SAAS,IAAI;AAKhC,IAAM,UAAU,MAAM,aAAmB,QAAQ,SAAO,GAAG,EACtD,OAAO,aAAmB,OAAO,CAAC,QAAsB,IAAI,GAAG,EAC3D,MAAM,EAAC,MAAM,MAAK,GAAG,EAAC,MAAM,MAAK,CAAC,CAAC,EACvC,KAAK,KAAK,OAAO,eAAe,CAAC;AAEtC,QAAQ,IAAI,OAAO;AACnB,OAAO,YAAY,IAAI;",
  "names": []
}
